\section{Булев поиск}

\subsection{Задание}

Реализовать систему булева поиска с поддержкой операторов пересечения, объединения и отрицания, ранжированием результатов и веб-интерфейсом для взаимодействия с пользователем.

\subsection{Описание метода решения задачи}

\subsubsection{Операторы булева поиска}

Реализованы три основных оператора с поддержкой нескольких синтаксисов:

\begin{itemize}
    \item \textbf{\&\&} (или \textbf{AND}, или \textbf{и}) --- пересечение множеств документов (документ должен содержать все термины)
    \item \textbf{||} (или \textbf{OR}, или \textbf{или}) --- объединение множеств документов (документ должен содержать хотя бы один термин)
    \item \textbf{!} (или \textbf{NOT}, или \textbf{не}) --- разность множеств (исключение документов, содержащих термин)
\end{itemize}

По умолчанию между терминами подразумевается оператор AND (неявное пересечение). Поддерживаются скобки для группировки: \texttt{(фонетика || фонология) \&\& язык}.

\subsection{Алгоритмы операций над множествами}

Все операции реализованы на отсортированных списках документов с линейной сложностью $O(n + m)$.

\textbf{Пересечение (AND):}
\begin{enumerate}
    \item Два указателя движутся по отсортированным posting lists
    \item При совпадении элементов --- добавление в результат и продвижение обоих указателей
    \item При несовпадении --- продвижение указателя на меньшем элементе
\end{enumerate}

\textbf{Объединение (OR):}
\begin{enumerate}
    \item Слияние двух отсортированных списков
    \item При совпадении --- добавление одного экземпляра и продвижение обоих
    \item При несовпадении --- добавление меньшего и продвижение его указателя
\end{enumerate}

\textbf{Разность (NOT):}
\begin{enumerate}
    \item Последовательный проход по первому списку
    \item Если элемент присутствует во втором списке --- пропуск
    \item Иначе --- добавление в результат
\end{enumerate}

\subsubsection{Парсинг запросов}

Анализатор запросов реализован в классе \texttt{BooleanSearch} с использованием рекурсивного спуска (recursive descent parser):

\begin{enumerate}
    \item Поддержка скобок для группировки выражений: \texttt{(термин1 || термин2) \&\& термин3}
    \item Приоритет операторов: \texttt{!} (отрицание) имеет наивысший приоритет, затем \texttt{\&\&} (пересечение), затем \texttt{||} (объединение)
    \item Распознаются операторы в нескольких форматах:
    \begin{itemize}
        \item Современный синтаксис: \texttt{\&\&}, \texttt{||}, \texttt{!}
        \item Классический синтаксис: \texttt{AND}, \texttt{OR}, \texttt{NOT}
        \item Русский синтаксис: \texttt{и}, \texttt{или}, \texttt{не}
    \end{itemize}
    \item Остальные слова считаются поисковыми терминами
    \item Термины проходят стемминг перед поиском в индексе
    \item По умолчанию между соседними терминами подразумевается оператор AND
\end{enumerate}

Алгоритм парсинга:
\begin{itemize}
    \item Рекурсивный спуск по грамматике выражений
    \item Построение дерева разбора с учётом приоритетов операторов
    \item Вычисление результата путём обхода дерева снизу вверх
    \item Эффективная обработка скобок через рекурсивные вызовы
\end{itemize}

\subsubsection{Ранжирование результатов}

Реализовано ранжирование по TF-IDF (Term Frequency-Inverse Document Frequency):
\begin{enumerate}
    \item Для каждого документа из результата вычисляется score
    \item Score $= \sum_{t \in Q} \text{tf}(t, d) \cdot \log_{10}\left(\frac{N}{\text{df}(t)}\right)$, где:
    \begin{itemize}
        \item $Q$ --- множество терминов запроса
        \item $\text{tf}(t, d)$ --- частота термина $t$ в документе $d$
        \item $N$ --- общее количество документов в корпусе
        \item $\text{df}(t)$ --- количество документов, содержащих термин $t$
    \end{itemize}
    \item Документы сортируются по убыванию score
\end{enumerate}

Преимущества TF-IDF перед простой TF-схемой:
\begin{itemize}
    \item Учитывается редкость термина: редкие термины получают больший вес
    \item Более релевантные результаты: документы с редкими терминами ранжируются выше
    \item Логарифмическое масштабирование IDF предотвращает чрезмерное влияние очень редких терминов
\end{itemize}

Для больших результирующих множеств используется эффективная сортировка слиянием (merge sort) с линейной сложностью по памяти.

\subsection{Примеры запросов}

\begin{table}[H]
\centering
\begin{tabular}{lll}
\toprule
\textbf{Запрос} & \textbf{Интерпретация} & \textbf{$\sim$Результатов} \\
\midrule
язык & язык (простой, неявный AND) & $\sim$15\,000 \\
морфология & морфолог (стемминг) & $\sim$3\,000 \\
синтаксис \&\& грамматика & синтаксис AND грамматик & $\sim$2\,000 \\
фонетика || фонология & фонет OR фонолог & $\sim$5\,000 \\
лингвистика ! компьютерн & лингвист NOT компьютерн & $\sim$8\,000 \\
(фонетика || фонология) \&\& язык & (фонет OR фонолог) AND язык & $\sim$1\,500 \\
Кирилл \&\& алфавит & кирилл AND алфавит & $\sim$40 \\
!английский \&\& грамматика & NOT английск AND грамматик & $\sim$4\,000 \\
\bottomrule
\end{tabular}
\caption{Примеры булевых запросов с новым синтаксисом}
\end{table}

\subsection{Производительность поиска}

\begin{itemize}
    \item Время ответа на простой запрос (1 термин): $< 10$ мс
    \item Время ответа на сложный булев запрос: $< 50$ мс
    \item Пропускная способность HTTP API: $> 100$ запросов/сек
\end{itemize}

\subsection{Веб-интерфейс}

Веб-интерфейс реализован на Python (Flask) и взаимодействует с C++ движком через HTTP API. Интерфейс полностью переведён на русский язык и предоставляет:
\begin{itemize}
    \item Поисковую форму с поддержкой булевых операторов (\&\&, ||, !) и скобок
    \item Отображение результатов с заголовками, URL и сниппетами
    \item Постраничную навигацию
    \item Вкладку с визуализацией закона Ципфа (Chart.js) с увеличенными размерами графиков для лучшей читаемости
    \item Вкладку со статистикой индекса
\end{itemize}

API-эндпоинты движка:
\begin{itemize}
    \item \texttt{GET /api/search?q=...} --- булев поиск
    \item \texttt{GET /api/stats} --- статистика индекса
    \item \texttt{GET /api/zipf?limit=N} --- данные для графика Ципфа
    \item \texttt{GET /api/document?url=...} --- получение документа
\end{itemize}

\subsection{Утилита командной строки (CLI)}

Движок поддерживает интерактивный режим CLI. Для запуска в режиме командной строки (без HTTP-сервера) используется \texttt{docker compose run} с переопределением команды:

\begin{verbatim}
# Запуск CLI (интерактивный режим)
docker compose run --rm engine /app/engine

# С указанием путей к данным
docker compose run --rm engine /app/engine --input /app/data/corpus.ndjson --dump /app/data/index.dump
\end{verbatim}

По умолчанию в Dockerfile указана команда \texttt{/app/engine --serve --port 9090}, поэтому для CLI необходимо явно передать \texttt{/app/engine} без флага \texttt{--serve}. Данные берутся из смонтированного тома \texttt{./data:/app/data} (корпус \texttt{corpus.ndjson} или дамп \texttt{index.dump}).

\textbf{Доступные команды:}
\begin{itemize}
    \item \texttt{<запрос>} --- поиск (поддержка \&\&, ||, !, скобок)
    \item \texttt{:stats} --- статистика индекса
    \item \texttt{:zipf [N]} --- топ N терминов по частоте (по умолчанию 20)
    \item \texttt{:dump [path]} --- сохранение дампа индекса
    \item \texttt{:help} --- справка
    \item \texttt{:quit} --- выход
\end{itemize}

\textbf{Пример сеанса CLI} (запрос <<Кирилл \&\& алфавит>> по корпусу лингвистики):
\begin{verbatim}
> Кирилл && алфавит

Found 40 results (0.2 ms):

  1. Алфавит
     https://ru.wikipedia.org/wiki/Алфавит
     TF-IDF: 58.34

  2. Глаголица
     https://ru.wikipedia.org/wiki/Глаголица
     TF-IDF: 37.08

  3. Дохристианская письменность у славян
     https://ru.wikipedia.org/wiki/...
     TF-IDF: 36.21

  4. Кириллица
     https://ru.wikipedia.org/wiki/Кириллица
     TF-IDF: 31.72

  5. Старославянский язык
     ...
     TF-IDF: 30.58

  ... and 30 more results

> :stats

=== Index Statistics ===
Documents:     30000
Vocabulary:    942795
Total tokens:  67464124

> :zipf

Top 20 terms:
      1. на                 1221340
      2. год               1022871
      3. был               828988
      ...
\end{verbatim}

\subsection{Демонстрация веб-интерфейса}

% TODO: Вставить скриншоты веб-интерфейса
\begin{center}
\textit{[Место для скриншота веб-интерфейса --- поиск]}

% Раскомментировать после добавления изображения:
% \begin{figure}[H]
% \centering
% \includegraphics[width=\textwidth]{images/ui_search.png}
% \caption{Веб-интерфейс: результаты поиска}
% \label{fig:ui_search}
% \end{figure}
\end{center}

\begin{center}
\textit{[Место для скриншота веб-интерфейса --- статистика]}

% Раскомментировать после добавления изображения:
% \begin{figure}[H]
% \centering
% \includegraphics[width=\textwidth]{images/ui_stats.png}
% \caption{Веб-интерфейс: статистика индекса}
% \label{fig:ui_stats}
% \end{figure}
\end{center}

\subsection{Контейнеризация и запуск}

Все компоненты упакованы в Docker-контейнеры и управляются через \texttt{docker-compose}:

\begin{verbatim}
# Сбор корпуса (однократно)
docker compose run --rm scraper

# Запуск движка и веб-интерфейса (HTTP-режим)
docker compose up engine frontend

# CLI-режим (интерактивный поиск в терминале)
docker compose run --rm engine /app/engine
\end{verbatim}

Веб-интерфейс доступен по адресу \texttt{http://localhost:8080}.

\subsection{Журнал выполнения задания}

В процессе реализации булева поиска были решены следующие задачи и проблемы:

\textbf{Реализация рекурсивного спуска:}
\begin{itemize}
    \item Изначально парсер использовал простой линейный разбор без учёта приоритетов операторов
    \item Для поддержки скобок и правильной обработки приоритетов потребовалась реализация рекурсивного спуска
    \item Сложность заключалась в корректной обработке вложенных скобок и унарного оператора отрицания
    \item Решение: построение дерева разбора с учётом грамматики выражений и приоритетов операторов
    \item Реализованы функции для каждого уровня приоритета: \texttt{parse\_or()}, \texttt{parse\_and()}, \texttt{parse\_not()}, \texttt{parse\_term()}
\end{itemize}

\textbf{Обработка приоритетов операторов:}
\begin{itemize}
    \item Критически важно было правильно реализовать приоритет: \texttt{!} > \texttt{\&\&} > \texttt{||}
    \item Неправильная обработка приоритетов приводила к неверной интерпретации запросов типа \texttt{!термин1 \&\& термин2}
    \item Решение: рекурсивный спуск начинается с оператора наименьшего приоритета (\texttt{||}), который вызывает парсеры более высоких приоритетов
    \item Это обеспечивает правильную ассоциативность и приоритет операций
\end{itemize}

\textbf{Интеграция TF-IDF:}
\begin{itemize}
    \item Переход с простой TF-схемы на TF-IDF потребовал вычисления document frequency для каждого термина
    \item Document frequency хранится в индексе как размер posting list для каждого термина
    \item Реализована эффективная функция вычисления IDF: $\log_{10}(N / \text{df}(t))$
    \item Логарифмическое масштабирование предотвращает чрезмерное влияние очень редких терминов
    \item Результат: более релевантное ранжирование с учётом редкости терминов
\end{itemize}

\textbf{Производительность при больших результатах:}
\begin{itemize}
    \item При запросах, возвращающих десятки тысяч документов, сортировка по TF-IDF может быть затратной
    \item Решение: использование эффективной сортировки слиянием (merge sort) с линейной сложностью по памяти
    \item Оптимизация: предварительное вычисление IDF для всех терминов запроса перед сортировкой
    \item Результат: время ответа остаётся приемлемым даже для больших результирующих множеств
\end{itemize}

\subsection{Выводы}

Реализована полнофункциональная система булева поиска с поддержкой операторов пересечения, объединения и отрицания, скобок для группировки, и ранжированием по TF-IDF.

\textbf{Критический анализ:}

\textbf{Достоинства:}
\begin{itemize}
    \item Гибкий синтаксис: поддержка нескольких форматов операторов (\&\&/||/!, AND/OR/NOT, русские операторы)
    \item Поддержка скобок: позволяет строить сложные запросы с явной группировкой
    \item Правильная обработка приоритетов: рекурсивный спуск обеспечивает корректную интерпретацию запросов
    \item TF-IDF ранжирование: более релевантные результаты по сравнению с простой TF-схемой
    \item Удобный интерфейс: русскоязычный веб-интерфейс с увеличенными графиками для лучшей читаемости
    \item Расширенный CLI: дополнительные команды для статистики, визуализации и управления индексом
\end{itemize}

\textbf{Сравнение TF и TF-IDF:}
\begin{itemize}
    \item \textbf{TF-схема}: проста в реализации, но не учитывает редкость терминов; общие слова получают такой же вес, как и специфические
    \item \textbf{TF-IDF}: учитывает редкость терминов через IDF; редкие термины получают больший вес, что повышает релевантность результатов
    \item На практике TF-IDF показывает лучшие результаты для информационного поиска, особенно при работе с большими корпусами
\end{itemize}

\textbf{Поддержка скобок:}
\begin{itemize}
    \item Скобки позволяют явно группировать операции, что критично для сложных запросов
    \item Пример: \texttt{(фонетика || фонология) \&\& язык} без скобок интерпретировался бы как \texttt{фонетика || (фонология \&\& язык)}
    \item Рекурсивный спуск обеспечивает правильную обработку вложенных скобок любой глубины
\end{itemize}

\textbf{Недостатки и возможные улучшения:}
\begin{itemize}
    \item \textbf{Фразовый поиск}: отсутствует поддержка поиска точных фраз; требуется позиционный индекс
    \item \textbf{Нечёткий поиск}: нет поддержки опечаток и вариаций написания; можно добавить fuzzy matching
    \item \textbf{Оптимизация запросов}: можно оптимизировать порядок выполнения операций для ускорения (начинать с самых редких терминов)
    \item \textbf{Кэширование}: можно добавить кэширование результатов частых запросов
\end{itemize}

\pagebreak
