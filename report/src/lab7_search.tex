\section{Булев поиск}

\subsection{Задание}

Реализовать систему булева поиска с поддержкой операторов пересечения, объединения и отрицания, ранжированием результатов и веб-интерфейсом для взаимодействия с пользователем.

\subsection{Описание метода решения задачи}

\subsubsection{Операторы булева поиска}

Реализованы три основных оператора с поддержкой нескольких синтаксисов:

\begin{itemize}
    \item \textbf{\&\&} (или \textbf{AND}, или \textbf{и}) --- пересечение множеств документов (документ должен содержать все термины)
    \item \textbf{||} (или \textbf{OR}, или \textbf{или}) --- объединение множеств документов (документ должен содержать хотя бы один термин)
    \item \textbf{!} (или \textbf{NOT}, или \textbf{не}) --- разность множеств (исключение документов, содержащих термин)
\end{itemize}

По умолчанию между терминами подразумевается оператор AND (неявное пересечение). Поддерживаются скобки для группировки: \texttt{(проза || поэзия) \&\& автор}.

\subsection{Алгоритмы операций над множествами}

Все операции реализованы на отсортированных списках документов с линейной сложностью $O(n + m)$.

\textbf{Пересечение (AND):}
\begin{enumerate}
    \item Два указателя движутся по отсортированным posting lists
    \item При совпадении элементов --- добавление в результат и продвижение обоих указателей
    \item При несовпадении --- продвижение указателя на меньшем элементе
\end{enumerate}

\textbf{Объединение (OR):}
\begin{enumerate}
    \item Слияние двух отсортированных списков
    \item При совпадении --- добавление одного экземпляра и продвижение обоих
    \item При несовпадении --- добавление меньшего и продвижение его указателя
\end{enumerate}

\textbf{Разность (NOT):}
\begin{enumerate}
    \item Последовательный проход по первому списку
    \item Если элемент присутствует во втором списке --- пропуск
    \item Иначе --- добавление в результат
\end{enumerate}

\subsubsection{Парсинг запросов}

Анализатор запросов реализован в классе \texttt{BooleanSearch} с использованием рекурсивного спуска (recursive descent parser):

\begin{enumerate}
    \item Поддержка скобок для группировки выражений: \texttt{(термин1 || термин2) \&\& термин3}
    \item Приоритет операторов: \texttt{!} (отрицание) имеет наивысший приоритет, затем \texttt{\&\&} (пересечение), затем \texttt{||} (объединение)
    \item Распознаются операторы в нескольких форматах:
    \begin{itemize}
        \item Современный синтаксис: \texttt{\&\&}, \texttt{||}, \texttt{!}
        \item Классический синтаксис: \texttt{AND}, \texttt{OR}, \texttt{NOT}
        \item Русский синтаксис: \texttt{и}, \texttt{или}, \texttt{не}
    \end{itemize}
    \item Остальные слова считаются поисковыми терминами
    \item Термины проходят стемминг перед поиском в индексе
    \item По умолчанию между соседними терминами подразумевается оператор AND
\end{enumerate}

Алгоритм парсинга:
\begin{itemize}
    \item Рекурсивный спуск по грамматике выражений
    \item Построение дерева разбора с учётом приоритетов операторов
    \item Вычисление результата путём обхода дерева снизу вверх
    \item Эффективная обработка скобок через рекурсивные вызовы
\end{itemize}

\subsubsection{Ранжирование результатов}

Реализовано ранжирование по TF-IDF (Term Frequency-Inverse Document Frequency):
\begin{enumerate}
    \item Для каждого документа из результата вычисляется score
    \item Score $= \sum_{t \in Q} \text{tf}(t, d) \cdot \log_{10}\left(\frac{N}{\text{df}(t)}\right)$, где:
    \begin{itemize}
        \item $Q$ --- множество терминов запроса
        \item $\text{tf}(t, d)$ --- частота термина $t$ в документе $d$
        \item $N$ --- общее количество документов в корпусе
        \item $\text{df}(t)$ --- количество документов, содержащих термин $t$
    \end{itemize}
    \item Документы сортируются по убыванию score
\end{enumerate}

Преимущества TF-IDF перед простой TF-схемой:
\begin{itemize}
    \item Учитывается редкость термина: редкие термины получают больший вес
    \item Более релевантные результаты: документы с редкими терминами ранжируются выше
    \item Логарифмическое масштабирование IDF предотвращает чрезмерное влияние очень редких терминов
\end{itemize}

Для больших результирующих множеств используется эффективная сортировка слиянием (merge sort) с линейной сложностью по памяти.

\subsection{Примеры запросов}

\begin{table}[H]
\centering
\begin{tabular}{lll}
\toprule
\textbf{Запрос} & \textbf{Интерпретация} & \textbf{$\sim$Результатов} \\
\midrule
роман & роман (простой, неявный AND) & $\sim$20\,000 \\
поэзия & поэз (стемминг) & $\sim$5\,000 \\
проза \&\& рассказ & проз AND рассказ & $\sim$1\,000 \\
литература || поэзия & литератур OR поэз & $\sim$15\,000 \\
роман ! детектив & роман NOT детектив & $\sim$18\,000 \\
(проза || поэзия) \&\& автор & (проз OR поэз) AND автор & $\sim$3\,000 \\
автор произведение & автор AND произведен (неявный AND) & $\sim$8\,000 \\
!детектив \&\& роман & NOT детектив AND роман & $\sim$18\,000 \\
\bottomrule
\end{tabular}
\caption{Примеры булевых запросов с новым синтаксисом}
\end{table}

\subsection{Производительность поиска}

\begin{itemize}
    \item Время ответа на простой запрос (1 термин): $< 10$ мс
    \item Время ответа на сложный булев запрос: $< 50$ мс
    \item Пропускная способность HTTP API: $> 100$ запросов/сек
\end{itemize}

\subsection{Веб-интерфейс}

Веб-интерфейс реализован на Python (Flask) и взаимодействует с C++ движком через HTTP API. Интерфейс полностью переведён на русский язык и предоставляет:
\begin{itemize}
    \item Поисковую форму с поддержкой булевых операторов (\&\&, ||, !) и скобок
    \item Отображение результатов с заголовками, URL и сниппетами
    \item Постраничную навигацию
    \item Вкладку с визуализацией закона Ципфа (Chart.js) с увеличенными размерами графиков для лучшей читаемости
    \item Вкладку со статистикой индекса
\end{itemize}

API-эндпоинты движка:
\begin{itemize}
    \item \texttt{GET /api/search?q=...} --- булев поиск
    \item \texttt{GET /api/stats} --- статистика индекса
    \item \texttt{GET /api/zipf?limit=N} --- данные для графика Ципфа
    \item \texttt{GET /api/document?url=...} --- получение документа
\end{itemize}

\subsection{Утилита командной строки}

Движок поддерживает интерактивный режим CLI с дополнительными командами:
\begin{verbatim}
> синтаксис && морфология
Найдено 523 результатов (12.4 мс):
1. https://ru.wikipedia.org/.../Синтаксис (score: 47.2)
2. https://ru.wikipedia.org/.../Морфология (score: 38.5)
...

> :stats
Статистика индекса:
  Документов: 35000
  Терминов: 480000
  ...

> :zipf
Отображение графика Ципфа...

> :dump
Сохранение дампа индекса в data/index.dump...

> :help
Доступные команды:
  :stats  - статистика индекса
  :zipf   - график Ципфа
  :dump   - сохранить дамп индекса
  :help   - справка
  :quit   - выход

> :quit
\end{verbatim}

\subsection{Демонстрация веб-интерфейса}

% TODO: Вставить скриншоты веб-интерфейса
\begin{center}
\textit{[Место для скриншота веб-интерфейса --- поиск]}

% Раскомментировать после добавления изображения:
% \begin{figure}[H]
% \centering
% \includegraphics[width=\textwidth]{images/ui_search.png}
% \caption{Веб-интерфейс: результаты поиска}
% \label{fig:ui_search}
% \end{figure}
\end{center}

\begin{center}
\textit{[Место для скриншота веб-интерфейса --- статистика]}

% Раскомментировать после добавления изображения:
% \begin{figure}[H]
% \centering
% \includegraphics[width=\textwidth]{images/ui_stats.png}
% \caption{Веб-интерфейс: статистика индекса}
% \label{fig:ui_stats}
% \end{figure}
\end{center}

\subsection{Контейнеризация и запуск}

Все компоненты упакованы в Docker-контейнеры и управляются через \texttt{docker-compose}:

\begin{verbatim}
# Сбор корпуса (однократно)
docker-compose up scraper

# Запуск движка и веб-интерфейса
docker-compose up engine frontend
\end{verbatim}

Веб-интерфейс доступен по адресу \texttt{http://localhost:8080}.

\subsection{Журнал выполнения задания}

В процессе реализации булева поиска были решены следующие задачи и проблемы:

\textbf{Реализация рекурсивного спуска:}
\begin{itemize}
    \item Изначально парсер использовал простой линейный разбор без учёта приоритетов операторов
    \item Для поддержки скобок и правильной обработки приоритетов потребовалась реализация рекурсивного спуска
    \item Сложность заключалась в корректной обработке вложенных скобок и унарного оператора отрицания
    \item Решение: построение дерева разбора с учётом грамматики выражений и приоритетов операторов
    \item Реализованы функции для каждого уровня приоритета: \texttt{parse\_or()}, \texttt{parse\_and()}, \texttt{parse\_not()}, \texttt{parse\_term()}
\end{itemize}

\textbf{Обработка приоритетов операторов:}
\begin{itemize}
    \item Критически важно было правильно реализовать приоритет: \texttt{!} > \texttt{\&\&} > \texttt{||}
    \item Неправильная обработка приоритетов приводила к неверной интерпретации запросов типа \texttt{!термин1 \&\& термин2}
    \item Решение: рекурсивный спуск начинается с оператора наименьшего приоритета (\texttt{||}), который вызывает парсеры более высоких приоритетов
    \item Это обеспечивает правильную ассоциативность и приоритет операций
\end{itemize}

\textbf{Интеграция TF-IDF:}
\begin{itemize}
    \item Переход с простой TF-схемы на TF-IDF потребовал вычисления document frequency для каждого термина
    \item Document frequency хранится в индексе как размер posting list для каждого термина
    \item Реализована эффективная функция вычисления IDF: $\log_{10}(N / \text{df}(t))$
    \item Логарифмическое масштабирование предотвращает чрезмерное влияние очень редких терминов
    \item Результат: более релевантное ранжирование с учётом редкости терминов
\end{itemize}

\textbf{Производительность при больших результатах:}
\begin{itemize}
    \item При запросах, возвращающих десятки тысяч документов, сортировка по TF-IDF может быть затратной
    \item Решение: использование эффективной сортировки слиянием (merge sort) с линейной сложностью по памяти
    \item Оптимизация: предварительное вычисление IDF для всех терминов запроса перед сортировкой
    \item Результат: время ответа остаётся приемлемым даже для больших результирующих множеств
\end{itemize}

\subsection{Выводы}

Реализована полнофункциональная система булева поиска с поддержкой операторов пересечения, объединения и отрицания, скобок для группировки, и ранжированием по TF-IDF.

\textbf{Критический анализ:}

\textbf{Достоинства:}
\begin{itemize}
    \item Гибкий синтаксис: поддержка нескольких форматов операторов (\&\&/||/!, AND/OR/NOT, русские операторы)
    \item Поддержка скобок: позволяет строить сложные запросы с явной группировкой
    \item Правильная обработка приоритетов: рекурсивный спуск обеспечивает корректную интерпретацию запросов
    \item TF-IDF ранжирование: более релевантные результаты по сравнению с простой TF-схемой
    \item Удобный интерфейс: русскоязычный веб-интерфейс с увеличенными графиками для лучшей читаемости
    \item Расширенный CLI: дополнительные команды для статистики, визуализации и управления индексом
\end{itemize}

\textbf{Сравнение TF и TF-IDF:}
\begin{itemize}
    \item \textbf{TF-схема}: проста в реализации, но не учитывает редкость терминов; общие слова получают такой же вес, как и специфические
    \item \textbf{TF-IDF}: учитывает редкость терминов через IDF; редкие термины получают больший вес, что повышает релевантность результатов
    \item На практике TF-IDF показывает лучшие результаты для информационного поиска, особенно при работе с большими корпусами
\end{itemize}

\textbf{Поддержка скобок:}
\begin{itemize}
    \item Скобки позволяют явно группировать операции, что критично для сложных запросов
    \item Пример: \texttt{(проза || поэзия) \&\& автор} без скобок интерпретировался бы как \texttt{проза || (поэзия \&\& автор)}
    \item Рекурсивный спуск обеспечивает правильную обработку вложенных скобок любой глубины
\end{itemize}

\textbf{Недостатки и возможные улучшения:}
\begin{itemize}
    \item \textbf{Фразовый поиск}: отсутствует поддержка поиска точных фраз; требуется позиционный индекс
    \item \textbf{Нечёткий поиск}: нет поддержки опечаток и вариаций написания; можно добавить fuzzy matching
    \item \textbf{Оптимизация запросов}: можно оптимизировать порядок выполнения операций для ускорения (начинать с самых редких терминов)
    \item \textbf{Кэширование}: можно добавить кэширование результатов частых запросов
\end{itemize}

\pagebreak
