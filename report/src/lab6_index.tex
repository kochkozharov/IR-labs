\section{Булев индекс}

\subsection{Структура инвертированного индекса}

Инвертированный индекс --- структура данных, сопоставляющая каждому термину список документов, в которых он встречается, вместе с частотами вхождений.

Компоненты индекса:
\begin{itemize}
    \item \textbf{Словарь терминов}: хеш-таблица \texttt{StringMap<PostingList>}, содержащая все уникальные термины после стемминга
    \item \textbf{Posting list}: для каждого термина --- вектор пар $(\text{doc\_id}, \text{frequency})$
    \item \textbf{Список документов}: массив URL всех документов корпуса
\end{itemize}

Индекс хранится целиком в оперативной памяти. При запуске движок автоматически проверяет наличие файла дампа индекса (\texttt{data/index.dump} по умолчанию, путь настраивается через флаг \texttt{--dump}). Если дамп найден, индекс загружается из него за несколько секунд. В противном случае корпус загружается из файла \texttt{corpus.ndjson}, выполняется индексация всех документов, и индекс сохраняется в дамп для последующих запусков.

\subsection{Собственные структуры данных}

Согласно требованиям задания, для хранения индекса используются собственные реализации структур данных (без контейнеров STL, за исключением \texttt{std::string} и \texttt{std::vector}).

\subsubsection{StringMap<V> --- хеш-таблица для строковых ключей}

Реализована хеш-таблица с открытой адресацией и двойным хешированием:

\begin{itemize}
    \item \texttt{insert(key, value)} --- вставка пары ключ-значение, $O(1)$ в среднем
    \item \texttt{find(key)} --- поиск по ключу, $O(1)$ в среднем
    \item \texttt{get\_or\_create(key)} --- получение значения или создание нового
    \item \texttt{for\_each(func)} --- итерация по всем элементам
    \item \texttt{size()} --- количество элементов
    \item \texttt{reserve(capacity)} --- резервирование памяти для эффективной десериализации
\end{itemize}

Характеристики:
\begin{itemize}
    \item Начальный размер: 16\,384 элемента
    \item Коэффициент заполнения для расширения: 50\%
    \item Коэффициент роста: удвоение размера при rehashing
    \item Разрешение коллизий: двойное хеширование ($h_1$ --- основной хеш, $h_2$ --- шаг)
    \item Важно: $h_2$ должен быть взаимно простым с размером таблицы; для степеней двойки используется $h_2 | 1$ для гарантии нечётности
\end{itemize}

Преимущества двойного хеширования:
\begin{itemize}
    \item Отсутствие указателей --- улучшенная локальность данных в кеше процессора
    \item Равномерное распределение элементов по таблице
    \item Быстрые операции вставки и поиска: $O(1)$ в среднем при факторе заполнения $< 0.5$
\end{itemize}

\subsection{Процесс построения индекса}

Для каждого документа из корпуса выполняется:

\begin{enumerate}
    \item Токенизация текста документа
    \item Стемминг каждого токена
    \item Для каждого стемированного термина --- обновление posting list в индексе:
    \begin{itemize}
        \item Если документ уже есть в posting list --- увеличение счётчика частоты
        \item Иначе --- добавление новой записи $(doc\_id, 1)$
    \end{itemize}
    \item Параллельно --- передача термина в анализатор Ципфа для статистики
\end{enumerate}

\subsection{Статистика индекса}

\begin{table}[H]
\centering
\begin{tabular}{lr}
\toprule
\textbf{Параметр} & \textbf{Значение} \\
\midrule
Проиндексировано документов & $\sim$30\,500 \\
Размер словаря & $\sim$480\,000 уникальных терминов \\
Время индексации & $\sim$60--90 секунд \\
Скорость обработки & $\sim$400--500 документов/сек \\
\bottomrule
\end{tabular}
\caption{Метрики индексации}
\end{table}

\subsection{Сохранение и загрузка индекса}

Для ускорения последующих запусков реализована возможность сохранения индекса в бинарный файл дампа:

\begin{itemize}
    \item \textbf{Формат дампа}: бинарный формат с магическим заголовком \texttt{"IRDUMP01"}
    \item \textbf{Содержимое дампа}:
    \begin{itemize}
        \item Полные тексты всех документов
        \item Список URL документов
        \item Словарь терминов с posting lists (doc\_id, frequency)
        \item Статистика Ципфа (частоты терминов)
        \item Метаданные индекса (количество документов, терминов, время создания)
    \end{itemize}
    \item \textbf{Автоматическое определение}: при запуске движок проверяет наличие файла \texttt{data/index.dump}
    \item \textbf{Путь к дампу}: настраивается через флаг командной строки \texttt{--dump <путь>}
    \item \textbf{Производительность}: загрузка дампа занимает секунды вместо минут, необходимых для переиндексации
\end{itemize}

При загрузке дампа используется метод \texttt{reserve()} хеш-таблицы для предварительного резервирования памяти, что значительно ускоряет десериализацию за счёт избежания множественных перераспределений памяти.

\subsection{Архитектура движка}

Поисковый движок реализован на C++ и работает как HTTP-сервер (библиотека \texttt{cpp-httplib}). При старте автоматически определяет наличие дампа индекса и загружает его, либо строит индекс заново из корпуса и сохраняет дамп для последующих запусков.

Структура исходного кода движка:

\begin{verbatim}
engine/src/
|-- main.cpp              - HTTP-сервер и CLI
|-- tokenizer.h/.cpp      - Токенизатор
|-- stemmer.h/.cpp         - Стеммер Портера
|-- inverted_index.h/.cpp - Инвертированный индекс
|-- boolean_search.h/.cpp - Булев поиск
|-- zipf_analyzer.h/.cpp  - Анализатор Ципфа
|-- json_reader.h/.cpp    - Чтение NDJSON
|-- string_map.h          - Хеш-таблица (строковые ключи)
+-- hash_table.h          - Хеш-таблица (обобщённая)
\end{verbatim}

\subsection{Журнал выполнения задания}

В процессе реализации инвертированного индекса были решены следующие задачи и проблемы:

\textbf{Проблема с памятью:}
\begin{itemize}
    \item Изначально Docker-контейнер был ограничен 4\,GB оперативной памяти
    \item При индексации корпуса объёмом $\sim$10\,GB возникали ошибки нехватки памяти
    \item Решение: увеличен лимит памяти контейнера до 16\,GB через настройки Docker
    \item Это позволило успешно индексировать весь корпус в оперативной памяти
\end{itemize}

\textbf{Ошибка в хеш-таблице:}
\begin{itemize}
    \item При использовании двойного хеширования обнаружена критическая ошибка: функция $h_2$ могла возвращать чётные значения
    \item Когда размер таблицы является степенью двойки, чётный шаг $h_2$ приводит к неполному зондированию (пропускаются некоторые слоты)
    \item Это вызывало бесконечные циклы при поиске и вставке элементов
    \item Решение: применение операции \texttt{| 1} к результату $h_2$ для гарантии нечётности шага
    \item Теперь $h_2$ всегда взаимно прост с размером таблицы, что обеспечивает полное покрытие всех слотов
\end{itemize}

\textbf{Реализация бинарной сериализации:}
\begin{itemize}
    \item Разработан эффективный формат бинарного дампа с магическим заголовком для проверки целостности
    \item Реализована последовательная запись всех компонентов индекса: документы, URL, словарь терминов, posting lists, статистика Ципфа
    \item Для ускорения десериализации добавлен метод \texttt{reserve()} в \texttt{StringMap} для предварительного резервирования памяти
    \item Это позволило сократить время загрузки индекса с минут до секунд
\end{itemize}

\subsection{Выводы}

Реализован полнофункциональный инвертированный индекс с использованием собственных структур данных. Хеш-таблица с двойным хешированием обеспечивает эффективный доступ к терминам за $O(1)$ в среднем.

\textbf{Критический анализ:}

\textbf{Достоинства:}
\begin{itemize}
    \item Эффективная структура данных: хеш-таблица обеспечивает быстрый поиск терминов
    \item Оптимизация памяти: использование двойного хеширования без указателей улучшает локальность данных
    \item Быстрый запуск: система дампов позволяет загружать индекс за секунды вместо переиндексации за минуты
    \item Модульность: чёткое разделение компонентов (индекс, поиск, статистика)
\end{itemize}

\textbf{Недостатки и ограничения:}
\begin{itemize}
    \item \textbf{Память}: весь индекс хранится в оперативной памяти, что ограничивает масштабируемость для очень больших корпусов ($> 1$М документов)
    \item \textbf{Сжатие}: отсутствует сжатие posting lists; можно применить VByte или Simple9 для экономии памяти
    \item \textbf{Обновление}: индекс статичен; для поддержки динамических обновлений потребуется более сложная архитектура
    \item \textbf{Формат дампа}: бинарный формат не является кроссплатформенным (зависит от порядка байтов и размера типов)
\end{itemize}

\textbf{Возможные улучшения:}
\begin{itemize}
    \item Реализация сжатия posting lists для уменьшения объёма памяти
    \item Поддержка инкрементальных обновлений индекса без полной переиндексации
    \item Кроссплатформенный формат дампа с явным указанием порядка байтов
    \item Разделение индекса на сегменты для поддержки корпусов, не помещающихся в память
\end{itemize}

\pagebreak
