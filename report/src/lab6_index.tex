\section{Булев индекс}

\subsection{Структура инвертированного индекса}

Инвертированный индекс --- структура данных, сопоставляющая каждому термину список документов, в которых он встречается, вместе с частотами вхождений.

Компоненты индекса:
\begin{itemize}
    \item \textbf{Словарь терминов}: хеш-таблица \texttt{StringMap<PostingList>}, содержащая все уникальные термины после стемминга
    \item \textbf{Posting list}: для каждого термина --- вектор пар $(\text{doc\_id}, \text{frequency})$
    \item \textbf{Список документов}: массив URL всех документов корпуса
\end{itemize}

Индекс хранится целиком в оперативной памяти. При запуске движка корпус загружается из файла \texttt{corpus.ndjson}, после чего выполняется индексация всех документов.

\subsection{Собственные структуры данных}

Согласно требованиям задания, для хранения индекса используются собственные реализации структур данных (без контейнеров STL, за исключением \texttt{std::string} и \texttt{std::vector}).

\subsubsection{StringMap<V> --- хеш-таблица для строковых ключей}

Реализована хеш-таблица с открытой адресацией и двойным хешированием:

\begin{itemize}
    \item \texttt{insert(key, value)} --- вставка пары ключ-значение, $O(1)$ в среднем
    \item \texttt{find(key)} --- поиск по ключу, $O(1)$ в среднем
    \item \texttt{get\_or\_create(key)} --- получение значения или создание нового
    \item \texttt{for\_each(func)} --- итерация по всем элементам
    \item \texttt{size()} --- количество элементов
\end{itemize}

Характеристики:
\begin{itemize}
    \item Начальный размер: 16\,384 элемента
    \item Коэффициент заполнения для расширения: 50\%
    \item Коэффициент роста: удвоение размера при rehashing
    \item Разрешение коллизий: двойное хеширование ($h_1$ --- основной хеш, $h_2$ --- шаг)
\end{itemize}

Преимущества двойного хеширования:
\begin{itemize}
    \item Отсутствие указателей --- улучшенная локальность данных в кеше процессора
    \item Равномерное распределение элементов по таблице
    \item Быстрые операции вставки и поиска: $O(1)$ в среднем при факторе заполнения $< 0.5$
\end{itemize}

\subsection{Процесс построения индекса}

Для каждого документа из корпуса выполняется:

\begin{enumerate}
    \item Токенизация текста документа
    \item Стемминг каждого токена
    \item Для каждого стемированного термина --- обновление posting list в индексе:
    \begin{itemize}
        \item Если документ уже есть в posting list --- увеличение счётчика частоты
        \item Иначе --- добавление новой записи $(doc\_id, 1)$
    \end{itemize}
    \item Параллельно --- передача термина в анализатор Ципфа для статистики
\end{enumerate}

\subsection{Статистика индекса}

\begin{table}[H]
\centering
\begin{tabular}{lr}
\toprule
\textbf{Параметр} & \textbf{Значение} \\
\midrule
Проиндексировано документов & $\sim$35\,000 \\
Размер словаря & $\sim$480\,000 уникальных терминов \\
Время индексации & $\sim$60--90 секунд \\
Скорость обработки & $\sim$400--500 документов/сек \\
\bottomrule
\end{tabular}
\caption{Метрики индексации}
\end{table}

\subsection{Архитектура движка}

Поисковый движок реализован на C++ и работает как HTTP-сервер (библиотека \texttt{cpp-httplib}). При старте загружает корпус, строит индекс в оперативной памяти, после чего начинает обслуживать запросы.

Структура исходного кода движка:

\begin{verbatim}
engine/src/
|-- main.cpp              - HTTP-сервер и CLI
|-- tokenizer.h/.cpp      - Токенизатор
|-- stemmer.h/.cpp         - Стеммер Портера
|-- inverted_index.h/.cpp - Инвертированный индекс
|-- boolean_search.h/.cpp - Булев поиск
|-- zipf_analyzer.h/.cpp  - Анализатор Ципфа
|-- json_reader.h/.cpp    - Чтение NDJSON
|-- string_map.h          - Хеш-таблица (строковые ключи)
+-- hash_table.h          - Хеш-таблица (обобщённая)
\end{verbatim}

\pagebreak
